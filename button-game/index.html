<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Jewels or Jail</title>
</head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.5.1/pixi.min.js"></script>
<body>
  <style>* {padding: -; margin: 0}</style>
  <script type="text/javascript">

    // Aliases
    let
        Application = PIXI.Application,
        loader = PIXI.loader,
        resources = PIXI.loader.resources,
        Container = PIXI.Container,
        Graphics = PIXI.Graphics,
        Text = PIXI.Text,
        TextStyle = PIXI.TextStyle,
        Sprite = PIXI.Sprite;

	//Create a Pixi Application
	let app = new Application({width: 640, height: 640, backgroundColor: 0xBBBBBB});

	//Add the canvas that Pixi automatically created for you to the HTML document
	app.renderer.view.style.position = "absolute";
	app.renderer.view.style.display = "block";
	app.renderer.autoResize = true;
	app.renderer.resize(window.innerWidth, window.innerHeight);
	document.body.appendChild(app.view);

	class Billboard {

	    constructor (params, callback) {
            // add defaults for missing params
            this.boardParams = JSON.parse(JSON.stringify(params));
            this.displayTicks = 0;
            // if (this.boardParams.hasOwnProperty('frontFaceColor') !== true) {
                // this.boardParams.frontFaceColor = 0xff00ff;
            // }

            // create the graphics
            this.callback = callback;
				this.board = new Container(); // main container for billboard
            this.board.x = 100;
            this.board.y = 100;
            this.board.width = 400;
            this.board.height = 200;
				this.board.interactive = true;
				this.board.buttonMode = true;

            this.board.background = this.board.addChild(new Graphics()
                .beginFill(0xbbbbbb, 0.7)
                .lineStyle(4, 0x000000, 1)
                .drawRect(0, 0, 400, 200)
                .endFill());

            let textStyle = new TextStyle({
                fontFamily: "Helvetica",
                fontSize: 36,
                align: "center",
                wordWrap: true,
                fill: "black"
            });

            this.board.message = this.board.addChild(new Text('Your Message Here', textStyle));
            this.board.visible = true;

            app.stage.addChild(this.board);
	   }

      displayText(text) {
            var oldText = this.board.message.text;
            this.board.message.text = text;
            this.board.visible=true;
            return oldText;
      }

      displayTextForSeconds(text, seconds) {
            this.displayTicks = 60 * seconds;
            var oldText = this.board.message.text;
            this.board.message.text = text;
            this.board.visible=true;
            app.ticker.add(function myself(delta) {
                this.displayTicks -= delta;
                if (this.displayTicks < 0) {
                   this.board.visible = false;
                   app.ticker.remove(myself, this);
                }
            }.bind(this));
            this.board.visible=true;
            return oldText;
      }

	}

	class Button {
	    constructor (params, callback) {
            // add defaults for missing params
            this.gameParams = JSON.parse(JSON.stringify(params));
            if (this.gameParams.hasOwnProperty('frontFaceColor') !== true) {
                this.gameParams.frontFaceColor = 0xff00ff;
            }
            if (this.gameParams.hasOwnProperty('backFaceColor') !== true) {
                this.gameParams.backFaceColor = 0x6666ff;
            }
            if (this.gameParams.hasOwnProperty('radius') !== true) {
                this.gameParams.radius = 60;
            }

            // create the graphics
            this.callback = callback;
				  this.disk = new Container(); // main container for disk
				  this.disk.interactive = true;
				  this.disk.buttonMode = true;

                  this.disk.mask = this.disk.addChild(new Graphics()
                      .beginFill(0xffffff)
                      .drawEllipse(0, 0, this.gameParams.radius, this.gameParams.radius)
                      .endFill());
                  this.disk.mask.width = 2 * this.gameParams.radius;
                  this.disk.mask.height = 2 * this.gameParams.radius;
                  this.disk.mask.isMask = true;

                  this.frontFaceContainer = this.disk.addChild(new Container());
                  this.frontFaceFill = this.frontFaceContainer.addChild(new Graphics())
                      .beginFill(this.gameParams.frontFaceColor)
                      .drawEllipse(0, 0, this.gameParams.radius, this.gameParams.radius)
                      .endFill();
                  
                  this.frontFaceText =
                          this.disk.addChild(new PIXI.Text('?',
                          {fontFamily : 'Arial', fontSize: 48, fill : 0x000000, align : 'center'}));
                  this.frontFaceText.x = - .2 * this.gameParams.radius;
                  this.frontFaceText.y = - .5 * this.gameParams.radius;
                  this.backFaceContainer = this.disk.addChild(new Container());
                  this.backFaceFill = this.backFaceContainer.addChild(new Graphics())
                      .beginFill(this.gameParams.backFaceColor)
                      .drawEllipse(0, 0, this.gameParams.radius, this.gameParams.radius)
                      .endFill();
				  this.backFaceContainer.visible = false;
                  
                  app.stage.addChild(this.disk);
				  this.disk.position.set(this.gameParams.centerX, this.gameParams.centerY);

                  this.gameState = {
                      firstClickCount: 0,   // number of times this has been the first click of a turn
                      secondClickCount: 0,  // see above
                      firstClickPending: false,  // 'true' means that a button has been clicked and is waiting for the second click of a turn
                      active: true,              // 'true' means still on the board
                      commonName: this.gameParams.commonName
                  };

                  // handle clicking
				  this.disk.on('click', clickHandler.bind(this));
				  this.container = app.stage.addChild( new Container());
	   }

       setWait(value) {     // A button has been pressed
           if (value === true) {
               this.spin(2);
               this.setFrontFaceColor(0xff000000);
           }
       }

       fail() {
           this.frontFaceContainer.visible = true;
           this.backFaceContainer.visible = false;
		   }

       success() {
           game.pending = false;
           this.gameState.active = false;
           this.frontFaceText.text = ':)';
           this.frontFaceText.rotation = Math.PI / 2;
           this.frontFaceText.x += 15;
           this.frontFaceContainer.visible = false;
           this.backFaceContainer.visible = false;
		   }

       spin(radPerSec) {
           app.ticker.add(this.rotateBack.bind(this));
		   }

       rotateBack(delta) {
		    this.backFaceContainer.rotation += .05;
		 }

       rotate(delta) {
		    this.rotation += .05;
		 }

       startToPerspect(radPerSec) {
	        app.ticker.add(this.perspect, this);
       }

       perspect(delta) {
		    this.buttonFront.children[0].width -= .05;
		    console.log('t.bF.c[].w: ' + this.buttonFront.children[0].width);
			 if (this.buttonFront.children[0].width < -60) {
			     this.buttonFront.children[0].width = 60;
			 }
		 }

	    selfDestruct() {
		       this.app.ticker.remove(this.step, this);
		       // this.pixiCircle.destroy();
	    }
	    step(delta) {
			   this.theButton.y += 5;
	    }
	}

    class Game {
	    constructor (params) {
            this.gameParams = JSON.parse(JSON.stringify(params));

            // if needed add extra entry to make four buttons/line
            if (this.gameParams.pairs.length % 2 !== 0) {
                this.gameParams.pairs.push({ commonName: 'Joker', itemOneName: 'Red', itemTwoName: 'Black' });
            }
            let xIncrement = 150, yIncrement = 150, buttonRadius = 60;
            this.pending = false;
            this.pendingCommonName = '';

            params.pairs.forEach(function(pair, pairIndex, pairArray) {
                imageNames.push( ('images/' + pair.itemOneName + '-' + pair.commonName + '.jpg').toLowerCase());
                imageNames.push( ('images/' + pair.itemTwoName + '-' + pair.commonName + '.jpg').toLowerCase());
                commonNames.push( (pair.commonName));
                commonNames.push( (pair.commonName));
            });

            [150, 300, 450, 600].forEach(function(xVal, xInd, xArray) {
                [150, 300, 450].forEach(function(yVal, yInd, yArray) {
                    buttons.push(new Button ({centerX: xVal, centerY: yVal}, this.sendMessage));
                }, this);
            }, this);

            loader.add(imageNames).load(this.setup);

            let buttonsParams = [];
            this.board = new Billboard({}, function(){});
            this.board.displayTextForSeconds("Let's play Presidential Couples!", 4);
            
        }

        start() {
            console.log('The game is a foot.');
            
            return this;
        }
		setup(context) {

          imageNames.forEach(function(jpg, jpgIndex, jpgArray) {
             faceSprites.push(new Sprite( loader.resources[jpg].texture));
          });

          buttons.forEach(function(buttonItem, buttonIndex, buttonArray) {
             buttonItem.gameState.commonName = commonNames[buttonIndex];
             let sprite = buttonItem.backFaceContainer.addChild(faceSprites[buttonIndex]);
             sprite.width = 120;
             sprite.height = 120;
             sprite.x = - sprite.width / 2;
             sprite.y = - sprite.height / 2;
         });
     }

        sendMessage(msg) {
            if (game.pending === true) {
                console.log('checking for a match to "' + game.pendingCommonName + '"');
                game.pending = false;
                if (game.pendingCommonName === msg.commonName) {
                  game.board.displayTextForSeconds('You found a match!', 5);
                  buttons.forEach(function(button, buttonIndex, buttonArray) {
                     if (button.gameState.commonName === msg.commonName) {
                        button.success();
                     }
                  });
                } else {
                  game.board.displayTextForSeconds('Sorry, try again', 5);
                  buttons.forEach(function(button, buttonIndex, buttonArray) {
                     if (button.gameState.active === true) {
                        button.fail();
                     }
                  });
                }
            } else {
               game.pending = true;
               buttons.forEach(function(buttonItem, buttonIndex, buttonArray) {
                    buttonItem.spin(buttonItem.frontFaceContainer, .2);
                    
                    buttonItem.gameState.firstClickPending = true;
                    game.pendingCommonName = msg.commonName;
               }, this);
               console.log('pick was "' + game.pendingCommonName + '"');
            }
        }
    }

    function clickHandler(event) {
        this.frontFaceContainer.visible = false;
        this.backFaceContainer.visible = true;
        if (game.pending === true) {
           if (this.hasOwnProperty('callback') === true) {
               this.tickCounter = 4 * 60;
               app.ticker.add(function myself(delta) {
                   this.tickCounter -= delta;
                   if (this.tickCounter < 0) {
                      this.callback({commonName: this.gameState.commonName, msg: 'hello from clicky'});
                      app.ticker.remove(myself, this);
                   }
               }.bind(this));
           }
        } else {
           game.pending = true;
        }
    }

	function randomInt(min, max) {
	  return Math.floor(Math.random() * (max - min + 1)) + min;
	}
   
    // randomly select one item from input and place it in output until done
    function randomizeArray(array) {
        let newArray = [];
        let itemCount = array.length;
        for (item = itemCount; item > 0; item--) {
            newArray.push(array.splice(randomInt(0, item - 1), 1));
        }
        return newArray;
    }
    // Global Game Data

    let imageNames = [];
    let commonNames = [];
    var faceSprites = [];
    var buttons = [];
    let gameParams = {
        category: 'Presidential Couples',
        pairs: [
            {
                commonName: 'Washington',
                itemOneName: 'George',
                itemTwoName: 'Martha'
            },
            {
                commonName: 'Adams',
                itemOneName: 'John',
                itemTwoName: 'Abigail'
            },
            {
                commonName: 'Lincoln',
                itemOneName: 'Abe',
                itemTwoName: 'Mary'
            },
            {
                commonName: 'Roosevelt',
                itemOneName: 'Franklin',
                itemTwoName: 'Eleanor'
            },
            {
                commonName: 'Clinton',
                itemOneName: 'Hillary',
                itemTwoName: 'Bill'
            },
            {
                commonName: 'Obama',
                itemOneName: 'Barack',
                itemTwoName: 'Michelle'
            },
        ]
    };

    // Game Logic

    let game = new Game(gameParams).start();

  </script>
</body>
</html>
